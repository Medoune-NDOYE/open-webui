function getModelData() {

	const session = pfcGetCurrentSession();
	const model = session.GetActiveModel();

	let cadModelData = {};

	function getFeatures(model) {
		return model ? model.ListItems(pfcModelItemType.ITEM_FEATURE)
			.filter(f => f && f.FeatType)
			.map(f => ({
				id: f.Id,
				type: f.FeatType.string().substring(9),
				...(f.GetName() != null ? { name: f.GetName() } : {})
			}))
			: [];
	}

	function valueOf(value) {
		if (value) {
			if ('discr' in value) {
				switch (value.discr) {
					case pfcParamValueType.PARAM_STRING: return value.StringValue;
					case pfcParamValueType.PARAM_INTEGER: return value.IntValue;
					case pfcParamValueType.PARAM_BOOLEAN: return value.BoolValue;
					case pfcParamValueType.PARAM_DOUBLE: return value.DoubleValue;
					case pfcParamValueType.PARAM_NOTE: return value.NoteId;
					default: return undefined;
				}
			}
			throw new Error(`${value} is not pfcParameterValue in function 'valueOf'`);
		}
		return value;
	}

	function getModelInfos(model) {
		const modelInfos = {};

		modelInfos['ModelType'] = model.Type.string();

		for (const key in model) {
			if (typeof model[key] !== "function") {
				const value = model[key];
				if (
					value === null ||
					["string", "number", "boolean"].includes(typeof value)
				) {
					modelInfos[key] = value;
				}
			}
		}
		return modelInfos;
	}

	function getMassProperties(model) {
		const result = {};

		try {
			const massProps = model.GetMassProperty?.();
			if (!massProps) return result;

			for (const key in massProps) {
				if (typeof massProps[key] !== 'function') {
					const value = massProps[key];
					if (
						value === null ||
						["string", "number", "boolean"].includes(typeof value)
					) {
						result[key] = value;
					}
				}
			}
		} catch (e) {
			console.warn("Mass properties for this model :", e.message);
		}
		return result;
	}

	function getParametersFromModel(model) {
		if (!model.ListParams) return [];

		const params = model.ListParams();
		if (!Array.isArray(params)) return [];

		return params.map(p => ({
			name: p.GetName(),
			type: p.Value.discr.string().replace("PARAM_", ""),
			value: valueOf(p.Value)
		}));
	}

	function getSelectedItems() {
		const result = [];

		try {
			const session = pfcGetCurrentSession();
			const selections = session.CurrentSelectionBuffer.Contents;

			if (!selections || selections.length === 0) {
				return { error: "No object selected" };
			}

			for (const sel of selections) {
				const entry = {};

				entry.selectionString = sel.SelectionString;
				
				if (sel.SelItem) {
					const item = sel.SelItem;
					entry.selectionType = "item";
					entry.id = sel.SelItem.Id;
					entry.name = sel.SelItem.GetName();
					entry.type = sel.SelItem.Type.string()
					
				} else if (sel.SelModel) {
					const model = sel.SelModel;
					entry.selectionType = "model";
					entry.name = sel.SelModel.FullName;
					entry.type = sel.SelModel.Type.string();
				} else {
					entry.selectionType = "unknown";
				}

				result.push(entry);
			}

			return result;
		} catch (e) {
			return { error: "Error retrieving selection : ", message: e.message };
		}
	}

	if (model) {

		cadModelData.general = getModelInfos ? getModelInfos(model) : {};
		cadModelData.massProperties = getMassProperties ? getMassProperties(model) : {};
		cadModelData.features = getFeatures ? getFeatures(model) : {};
		cadModelData.parameters = getParametersFromModel ? getParametersFromModel(model) : {};
		cadModelData.selectedItems = getSelectedItems ? getSelectedItems(model) : {};

	} else {
		cadModelData.error = "No active model";
	}

	return cadModelData;
}